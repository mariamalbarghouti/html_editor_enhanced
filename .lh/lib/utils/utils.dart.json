{
    "sourceFile": "lib/utils/utils.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1720994958625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1720994958625,
            "name": "Commit-0",
            "content": "import 'dart:convert';\r\nimport 'dart:math';\r\n\r\nimport 'package:flutter/foundation.dart';\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter/rendering.dart';\r\nimport 'package:flutter/services.dart';\r\nimport 'package:html_editor_enhanced/html_editor.dart';\r\nimport 'package:html_editor_enhanced/utils/shims/dart_ui.dart';\r\n\r\n/// small function to always check if mounted before running setState()\r\nvoid setState(\r\n    bool mounted, void Function(Function()) setState, void Function() fn) {\r\n  if (mounted) {\r\n    setState.call(fn);\r\n  }\r\n}\r\n\r\n/// courtesy of @modulovalue (https://github.com/modulovalue/dart_intersperse/blob/master/lib/src/intersperse.dart)\r\n/// intersperses elements in between list items - used to insert dividers between\r\n/// toolbar buttons when using [ToolbarType.nativeScrollable]\r\nIterable<T> intersperse<T>(T element, Iterable<T> iterable) sync* {\r\n  final iterator = iterable.iterator;\r\n  if (iterator.moveNext()) {\r\n    yield iterator.current;\r\n    while (iterator.moveNext()) {\r\n      yield element;\r\n      yield iterator.current;\r\n    }\r\n  }\r\n}\r\n\r\n/// Generates a random string to be used as the [VisibilityDetector] key.\r\n/// Technically this limits the number of editors to a finite number, but\r\n/// nobody will be embedding enough editors to reach the theoretical limit\r\n/// (yes, this is a challenge ;-) )\r\nString getRandString(int len) {\r\n  var random = Random.secure();\r\n  var values = List<int>.generate(len, (i) => random.nextInt(255));\r\n  return base64UrlEncode(values);\r\n}\r\n\r\n/// Class that helps pass editor settings to the [onSettingsChange] callback\r\nclass EditorSettings {\r\n  String parentElement;\r\n  String fontName;\r\n  double fontSize;\r\n  bool isBold;\r\n  bool isItalic;\r\n  bool isUnderline;\r\n  bool isStrikethrough;\r\n  bool isSuperscript;\r\n  bool isSubscript;\r\n  Color foregroundColor;\r\n  Color backgroundColor;\r\n  bool isUl;\r\n  bool isOl;\r\n  bool isAlignLeft;\r\n  bool isAlignCenter;\r\n  bool isAlignRight;\r\n  bool isAlignJustify;\r\n  double lineHeight;\r\n  TextDirection textDirection;\r\n\r\n  EditorSettings({\r\n    required this.parentElement,\r\n    required this.fontName,\r\n    required this.fontSize,\r\n    required this.isBold,\r\n    required this.isItalic,\r\n    required this.isUnderline,\r\n    required this.isStrikethrough,\r\n    required this.isSuperscript,\r\n    required this.isSubscript,\r\n    required this.foregroundColor,\r\n    required this.backgroundColor,\r\n    required this.isUl,\r\n    required this.isOl,\r\n    required this.isAlignLeft,\r\n    required this.isAlignCenter,\r\n    required this.isAlignRight,\r\n    required this.isAlignJustify,\r\n    required this.lineHeight,\r\n    required this.textDirection,\r\n  });\r\n}\r\n\r\n/// Class to create a script that can be run on Flutter Web.\r\n///\r\n/// [name] provides a unique identifier for the script. Note: It must be unique!\r\n/// Otherwise your script may not be called when using [controller.evaluateJavascriptWeb].\r\n/// [script] provides the script itself. If you'd like to return a value back to\r\n/// Dart, you can do that via a postMessage call (see the README for an example).\r\nclass WebScript {\r\n  String name;\r\n  String script;\r\n\r\n  WebScript({\r\n    required this.name,\r\n    required this.script,\r\n  }) : assert(name.isNotEmpty && script.isNotEmpty);\r\n}\r\n\r\n/// Delegate for the icon that controls the expansion status of the toolbar\r\nclass ExpandIconDelegate extends SliverPersistentHeaderDelegate {\r\n  final double? _size;\r\n  final bool _isExpanded;\r\n  final void Function() _setState;\r\n\r\n  ExpandIconDelegate(this._size, this._isExpanded, this._setState);\r\n\r\n  @override\r\n  Widget build(\r\n      BuildContext context, double shrinkOffset, bool overlapsContent) {\r\n    return Container(\r\n      height: _size,\r\n      width: _size,\r\n      color: Theme.of(context).scaffoldBackgroundColor,\r\n      child: IconButton(\r\n        constraints: BoxConstraints(\r\n          maxHeight: _size!,\r\n          maxWidth: _size!,\r\n        ),\r\n        iconSize: _size! * 3 / 5,\r\n        icon: Icon(\r\n          _isExpanded ? Icons.expand_less : Icons.expand_more,\r\n          color: Colors.grey,\r\n        ),\r\n        onPressed: () async {\r\n          _setState.call();\r\n        },\r\n      ),\r\n    );\r\n  }\r\n\r\n  @override\r\n  double get maxExtent => _size!;\r\n\r\n  @override\r\n  double get minExtent => _size!;\r\n\r\n  @override\r\n  bool shouldRebuild(SliverPersistentHeaderDelegate oldDelegate) {\r\n    return true;\r\n  }\r\n}\r\n\r\n/// The following code contains all the code necessary for custom dropdowns.\r\n/// It is really long because dropdowns utilize a bunch of private classes that\r\n/// must be copy pasted.\r\n/// The main change is marked with a comment in the code (CTRL-F \"main change\")\r\n\r\nconst Duration _kDropdownMenuDuration = Duration(milliseconds: 300);\r\nconst double _kMenuItemHeight = kMinInteractiveDimension;\r\nconst double _kDenseButtonHeight = 24.0;\r\nconst EdgeInsets _kMenuItemPadding = EdgeInsets.symmetric(horizontal: 16.0);\r\nconst EdgeInsetsGeometry _kAlignedButtonPadding =\r\n    EdgeInsetsDirectional.only(start: 16.0, end: 4.0);\r\nconst EdgeInsets _kUnalignedButtonPadding = EdgeInsets.zero;\r\nconst EdgeInsets _kAlignedMenuMargin = EdgeInsets.zero;\r\nconst EdgeInsetsGeometry _kUnalignedMenuMargin =\r\n    EdgeInsetsDirectional.only(start: 16.0, end: 24.0);\r\n\r\ntypedef DropdownButtonBuilder = List<Widget> Function(BuildContext context);\r\n\r\nclass _DropdownMenuPainter extends CustomPainter {\r\n  _DropdownMenuPainter({\r\n    this.color,\r\n    this.elevation,\r\n    this.selectedIndex,\r\n    required this.resize,\r\n    required this.getSelectedItemOffset,\r\n  })  : _painter = BoxDecoration(\r\n          color: color,\r\n          borderRadius: BorderRadius.circular(2.0),\r\n          boxShadow: kElevationToShadow[elevation],\r\n        ).createBoxPainter(),\r\n        super(repaint: resize);\r\n\r\n  final Color? color;\r\n  final int? elevation;\r\n  final int? selectedIndex;\r\n  final Animation<double> resize;\r\n  final ValueGetter<double> getSelectedItemOffset;\r\n  final BoxPainter _painter;\r\n\r\n  @override\r\n  void paint(Canvas canvas, Size size) {\r\n    final selectedItemOffset = getSelectedItemOffset();\r\n    final top = Tween<double>(\r\n      begin: selectedItemOffset.clamp(\r\n          0.0, max(size.height - _kMenuItemHeight, 0.0)),\r\n      end: 0.0,\r\n    );\r\n\r\n    final bottom = Tween<double>(\r\n      begin: (top.begin! + _kMenuItemHeight)\r\n          .clamp(min(_kMenuItemHeight, size.height), size.height),\r\n      end: size.height,\r\n    );\r\n\r\n    final rect = Rect.fromLTRB(\r\n        0.0, top.evaluate(resize), size.width, bottom.evaluate(resize));\r\n\r\n    _painter.paint(canvas, rect.topLeft, ImageConfiguration(size: rect.size));\r\n  }\r\n\r\n  @override\r\n  bool shouldRepaint(_DropdownMenuPainter oldPainter) {\r\n    return oldPainter.color != color ||\r\n        oldPainter.elevation != elevation ||\r\n        oldPainter.selectedIndex != selectedIndex ||\r\n        oldPainter.resize != resize;\r\n  }\r\n}\r\n\r\nclass _DropdownMenuItemButton<T> extends StatefulWidget {\r\n  const _DropdownMenuItemButton({\r\n    Key? key,\r\n    this.padding,\r\n    required this.route,\r\n    required this.buttonRect,\r\n    required this.constraints,\r\n    required this.itemIndex,\r\n  }) : super(key: key);\r\n\r\n  final _DropdownRoute<T> route;\r\n  final EdgeInsets? padding;\r\n  final Rect buttonRect;\r\n  final BoxConstraints constraints;\r\n  final int itemIndex;\r\n\r\n  @override\r\n  _DropdownMenuItemButtonState<T> createState() =>\r\n      _DropdownMenuItemButtonState<T>();\r\n}\r\n\r\nclass _DropdownMenuItemButtonState<T>\r\n    extends State<_DropdownMenuItemButton<T>> {\r\n  void _handleFocusChange(bool focused) {\r\n    final bool inTraditionalMode;\r\n    switch (FocusManager.instance.highlightMode) {\r\n      case FocusHighlightMode.touch:\r\n        inTraditionalMode = false;\r\n        break;\r\n      case FocusHighlightMode.traditional:\r\n        inTraditionalMode = true;\r\n        break;\r\n    }\r\n\r\n    if (focused && inTraditionalMode) {\r\n      final menuLimits = widget.route.getMenuLimits(\r\n        widget.buttonRect,\r\n        widget.constraints.maxHeight,\r\n        widget.itemIndex,\r\n      );\r\n      widget.route.scrollController!.animateTo(\r\n        menuLimits.scrollOffset,\r\n        curve: Curves.easeInOut,\r\n        duration: const Duration(milliseconds: 100),\r\n      );\r\n    }\r\n  }\r\n\r\n  void _handleOnTap() {\r\n    final dropdownMenuItem = widget.route.items[widget.itemIndex].item!;\r\n\r\n    dropdownMenuItem.onTap?.call();\r\n\r\n    Navigator.pop(\r\n      context,\r\n      _DropdownRouteResult<T>(dropdownMenuItem.value),\r\n    );\r\n  }\r\n\r\n  static final Map<LogicalKeySet, Intent> _webShortcuts =\r\n      <LogicalKeySet, Intent>{\r\n    LogicalKeySet(LogicalKeyboardKey.arrowDown):\r\n        const DirectionalFocusIntent(TraversalDirection.down),\r\n    LogicalKeySet(LogicalKeyboardKey.arrowUp):\r\n        const DirectionalFocusIntent(TraversalDirection.up),\r\n  };\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    final CurvedAnimation opacity;\r\n    final unit = 0.5 / (widget.route.items.length + 1.5);\r\n    if (widget.itemIndex == widget.route.selectedIndex) {\r\n      opacity = CurvedAnimation(\r\n          parent: widget.route.animation!, curve: const Threshold(0.0));\r\n    } else {\r\n      final start = (0.5 + (widget.itemIndex + 1) * unit).clamp(0.0, 1.0);\r\n      final end = (start + 1.5 * unit).clamp(0.0, 1.0);\r\n      opacity = CurvedAnimation(\r\n          parent: widget.route.animation!, curve: Interval(start, end));\r\n    }\r\n    Widget child = FadeTransition(\r\n      opacity: opacity,\r\n      child: InkWell(\r\n        autofocus: widget.itemIndex == widget.route.selectedIndex,\r\n        onTap: _handleOnTap,\r\n        onFocusChange: _handleFocusChange,\r\n        child: Container(\r\n          padding: widget.padding,\r\n          child: widget.route.items[widget.itemIndex],\r\n        ),\r\n      ),\r\n    );\r\n    if (kIsWeb) {\r\n      child = Shortcuts(\r\n        shortcuts: _webShortcuts,\r\n        child: child,\r\n      );\r\n    }\r\n    return child;\r\n  }\r\n}\r\n\r\nclass _DropdownMenu<T> extends StatefulWidget {\r\n  const _DropdownMenu({\r\n    Key? key,\r\n    this.padding,\r\n    required this.route,\r\n    required this.buttonRect,\r\n    required this.constraints,\r\n    this.dropdownColor,\r\n  }) : super(key: key);\r\n\r\n  final _DropdownRoute<T> route;\r\n  final EdgeInsets? padding;\r\n  final Rect buttonRect;\r\n  final BoxConstraints constraints;\r\n  final Color? dropdownColor;\r\n\r\n  @override\r\n  _DropdownMenuState<T> createState() => _DropdownMenuState<T>();\r\n}\r\n\r\nclass _DropdownMenuState<T> extends State<_DropdownMenu<T>> {\r\n  late CurvedAnimation _fadeOpacity;\r\n  late CurvedAnimation _resize;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _fadeOpacity = CurvedAnimation(\r\n      parent: widget.route.animation!,\r\n      curve: const Interval(0.0, 0.25),\r\n      reverseCurve: const Interval(0.75, 1.0),\r\n    );\r\n    _resize = CurvedAnimation(\r\n      parent: widget.route.animation!,\r\n      curve: const Interval(0.25, 0.5),\r\n      reverseCurve: const Threshold(0.0),\r\n    );\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    assert(debugCheckHasMaterialLocalizations(context));\r\n    final localizations = MaterialLocalizations.of(context);\r\n    final route = widget.route;\r\n    final children = <Widget>[\r\n      for (int itemIndex = 0; itemIndex < route.items.length; ++itemIndex)\r\n        _DropdownMenuItemButton<T>(\r\n          route: widget.route,\r\n          padding: widget.padding,\r\n          buttonRect: widget.buttonRect,\r\n          constraints: widget.constraints,\r\n          itemIndex: itemIndex,\r\n        ),\r\n    ];\r\n\r\n    return FadeTransition(\r\n      opacity: _fadeOpacity,\r\n      child: CustomPaint(\r\n        painter: _DropdownMenuPainter(\r\n          color: widget.dropdownColor ?? Theme.of(context).canvasColor,\r\n          elevation: route.elevation,\r\n          selectedIndex: route.selectedIndex,\r\n          resize: _resize,\r\n          getSelectedItemOffset: () => route.getItemOffset(route.selectedIndex),\r\n        ),\r\n        child: Semantics(\r\n          scopesRoute: true,\r\n          namesRoute: true,\r\n          explicitChildNodes: true,\r\n          label: localizations.popupMenuLabel,\r\n          child: Material(\r\n            type: MaterialType.transparency,\r\n            textStyle: route.style,\r\n            child: ScrollConfiguration(\r\n              behavior: ScrollConfiguration.of(context).copyWith(\r\n                overscroll: false,\r\n                physics: const ClampingScrollPhysics(),\r\n                platform: Theme.of(context).platform,\r\n              ),\r\n              child: PrimaryScrollController(\r\n                controller: widget.route.scrollController!,\r\n                child: Scrollbar(\r\n                  thumbVisibility: true,\r\n                  child: ListView(\r\n                    padding: kMaterialListPadding,\r\n                    shrinkWrap: true,\r\n                    children: children,\r\n                  ),\r\n                ),\r\n              ),\r\n            ),\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _DropdownMenuRouteLayout<T> extends SingleChildLayoutDelegate {\r\n  _DropdownMenuRouteLayout({\r\n    required this.buttonRect,\r\n    required this.route,\r\n    required this.textDirection,\r\n  });\r\n\r\n  final Rect buttonRect;\r\n  final _DropdownRoute<T> route;\r\n  final TextDirection? textDirection;\r\n\r\n  @override\r\n  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {\r\n    var maxHeight = max(0.0, constraints.maxHeight - 2 * _kMenuItemHeight);\r\n    if (route.menuMaxHeight != null && route.menuMaxHeight! <= maxHeight) {\r\n      maxHeight = route.menuMaxHeight!;\r\n    }\r\n    final width = min(constraints.maxWidth, buttonRect.width);\r\n    return BoxConstraints(\r\n      minWidth: width,\r\n      maxWidth: width,\r\n      minHeight: 0.0,\r\n      maxHeight: maxHeight,\r\n    );\r\n  }\r\n\r\n  @override\r\n  Offset getPositionForChild(Size size, Size childSize) {\r\n    final menuLimits =\r\n        route.getMenuLimits(buttonRect, size.height, route.selectedIndex);\r\n\r\n    assert(() {\r\n      final container = Offset.zero & size;\r\n      if (container.intersect(buttonRect) == buttonRect) {\r\n        assert(menuLimits.top >= 0.0);\r\n        assert(menuLimits.top + menuLimits.height <= size.height);\r\n      }\r\n      return true;\r\n    }());\r\n    assert(textDirection != null);\r\n    final double left;\r\n    switch (textDirection!) {\r\n      case TextDirection.rtl:\r\n        left = buttonRect.right.clamp(0.0, size.width) - childSize.width;\r\n        break;\r\n      case TextDirection.ltr:\r\n        left = buttonRect.left.clamp(0.0, size.width - childSize.width);\r\n        break;\r\n    }\r\n\r\n    return Offset(left, menuLimits.top);\r\n  }\r\n\r\n  @override\r\n  bool shouldRelayout(_DropdownMenuRouteLayout<T> oldDelegate) {\r\n    return buttonRect != oldDelegate.buttonRect ||\r\n        textDirection != oldDelegate.textDirection;\r\n  }\r\n}\r\n\r\n@immutable\r\nclass _DropdownRouteResult<T> {\r\n  const _DropdownRouteResult(this.result);\r\n\r\n  final T? result;\r\n\r\n  @override\r\n  bool operator ==(Object other) {\r\n    return other is _DropdownRouteResult<T> && other.result == result;\r\n  }\r\n\r\n  @override\r\n  int get hashCode => result.hashCode;\r\n}\r\n\r\nclass _MenuLimits {\r\n  const _MenuLimits(this.top, this.bottom, this.height, this.scrollOffset);\r\n  final double top;\r\n  final double bottom;\r\n  final double height;\r\n  final double scrollOffset;\r\n}\r\n\r\nclass _DropdownRoute<T> extends PopupRoute<_DropdownRouteResult<T>> {\r\n  _DropdownRoute({\r\n    required this.items,\r\n    required this.padding,\r\n    required this.buttonRect,\r\n    required this.selectedIndex,\r\n    this.elevation = 8,\r\n    required this.capturedThemes,\r\n    required this.style,\r\n    this.barrierLabel,\r\n    this.itemHeight,\r\n    this.dropdownColor,\r\n    this.menuMaxHeight,\r\n    required this.menuDirection,\r\n  }) : itemHeights = List<double>.filled(\r\n            items.length, itemHeight ?? kMinInteractiveDimension);\r\n\r\n  final List<_MenuItem<T>> items;\r\n  final EdgeInsetsGeometry padding;\r\n  final Rect buttonRect;\r\n  final int selectedIndex;\r\n  final int elevation;\r\n  final CapturedThemes capturedThemes;\r\n  final TextStyle style;\r\n  final double? itemHeight;\r\n  final Color? dropdownColor;\r\n  final double? menuMaxHeight;\r\n  final DropdownMenuDirection menuDirection;\r\n\r\n  final List<double> itemHeights;\r\n  ScrollController? scrollController;\r\n\r\n  @override\r\n  Duration get transitionDuration => _kDropdownMenuDuration;\r\n\r\n  @override\r\n  bool get barrierDismissible => true;\r\n\r\n  @override\r\n  Color? get barrierColor => null;\r\n\r\n  @override\r\n  final String? barrierLabel;\r\n\r\n  @override\r\n  Widget buildPage(BuildContext context, Animation<double> animation,\r\n      Animation<double> secondaryAnimation) {\r\n    return LayoutBuilder(\r\n      builder: (BuildContext context, BoxConstraints constraints) {\r\n        return _DropdownRoutePage<T>(\r\n          route: this,\r\n          constraints: constraints,\r\n          items: items,\r\n          padding: padding,\r\n          buttonRect: buttonRect,\r\n          selectedIndex: selectedIndex,\r\n          elevation: elevation,\r\n          capturedThemes: capturedThemes,\r\n          style: style,\r\n          dropdownColor: dropdownColor,\r\n        );\r\n      },\r\n    );\r\n  }\r\n\r\n  void _dismiss() {\r\n    if (isActive) {\r\n      navigator?.removeRoute(this);\r\n    }\r\n  }\r\n\r\n  double getItemOffset(int index) {\r\n    var offset = kMaterialListPadding.top;\r\n    if (items.isNotEmpty && index > 0) {\r\n      assert(items.length == itemHeights.length);\r\n      offset += itemHeights\r\n          .sublist(0, index)\r\n          .reduce((double total, double height) => total + height);\r\n    }\r\n    return offset;\r\n  }\r\n\r\n  _MenuLimits getMenuLimits(\r\n      Rect buttonRect, double availableHeight, int index) {\r\n    final maxMenuHeight = availableHeight - 2.0 * _kMenuItemHeight;\r\n    final buttonTop = buttonRect.top;\r\n    final buttonBottom = min(buttonRect.bottom, availableHeight);\r\n    final selectedItemOffset = getItemOffset(index);\r\n\r\n    final topLimit = min(_kMenuItemHeight, buttonTop);\r\n    final bottomLimit = max(availableHeight - _kMenuItemHeight, buttonBottom);\r\n\r\n    var preferredMenuHeight = kMaterialListPadding.vertical;\r\n    if (items.isNotEmpty) {\r\n      preferredMenuHeight +=\r\n          itemHeights.reduce((double total, double height) => total + height);\r\n    }\r\n\r\n    final menuHeight = min(maxMenuHeight, preferredMenuHeight);\r\n    //the next two lines are the main change for reversed dropdown opening\r\n    var menuTop = menuDirection == DropdownMenuDirection.up\r\n        ? buttonTop - min((menuMaxHeight ?? menuHeight), menuHeight)\r\n        : (buttonTop - selectedItemOffset) -\r\n            (itemHeights[selectedIndex] - buttonRect.height) / 2.0;\r\n    var menuBottom = menuTop + min((menuMaxHeight ?? menuHeight), menuHeight);\r\n\r\n    if (menuTop < topLimit) {\r\n      menuTop = min(buttonTop, topLimit);\r\n    }\r\n\r\n    if (menuBottom > bottomLimit) {\r\n      menuBottom = max(buttonBottom, bottomLimit);\r\n      menuTop = menuBottom - menuHeight;\r\n    }\r\n\r\n    var scrollOffset = 0.0;\r\n    if (preferredMenuHeight > maxMenuHeight) {\r\n      scrollOffset = max(0.0, selectedItemOffset - (buttonTop - menuTop));\r\n      scrollOffset = min(scrollOffset, preferredMenuHeight - menuHeight);\r\n    }\r\n\r\n    return _MenuLimits(menuTop, menuBottom, menuHeight, scrollOffset);\r\n  }\r\n}\r\n\r\nclass _DropdownRoutePage<T> extends StatelessWidget {\r\n  const _DropdownRoutePage({\r\n    Key? key,\r\n    required this.route,\r\n    required this.constraints,\r\n    this.items,\r\n    required this.padding,\r\n    required this.buttonRect,\r\n    required this.selectedIndex,\r\n    this.elevation = 8,\r\n    required this.capturedThemes,\r\n    this.style,\r\n    required this.dropdownColor,\r\n  }) : super(key: key);\r\n\r\n  final _DropdownRoute<T> route;\r\n  final BoxConstraints constraints;\r\n  final List<_MenuItem<T>>? items;\r\n  final EdgeInsetsGeometry padding;\r\n  final Rect buttonRect;\r\n  final int selectedIndex;\r\n  final int elevation;\r\n  final CapturedThemes capturedThemes;\r\n  final TextStyle? style;\r\n  final Color? dropdownColor;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    assert(debugCheckHasDirectionality(context));\r\n    if (route.scrollController == null) {\r\n      final menuLimits =\r\n          route.getMenuLimits(buttonRect, constraints.maxHeight, selectedIndex);\r\n      route.scrollController =\r\n          ScrollController(initialScrollOffset: menuLimits.scrollOffset);\r\n    }\r\n\r\n    final textDirection = Directionality.maybeOf(context);\r\n    final Widget menu = _DropdownMenu<T>(\r\n      route: route,\r\n      padding: padding.resolve(textDirection),\r\n      buttonRect: buttonRect,\r\n      constraints: constraints,\r\n      dropdownColor: dropdownColor,\r\n    );\r\n\r\n    return MediaQuery.removePadding(\r\n      context: context,\r\n      removeTop: true,\r\n      removeBottom: true,\r\n      removeLeft: true,\r\n      removeRight: true,\r\n      child: Builder(\r\n        builder: (BuildContext context) {\r\n          return CustomSingleChildLayout(\r\n            delegate: _DropdownMenuRouteLayout<T>(\r\n              buttonRect: buttonRect,\r\n              route: route,\r\n              textDirection: textDirection,\r\n            ),\r\n            child: capturedThemes.wrap(menu),\r\n          );\r\n        },\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nclass _MenuItem<T> extends SingleChildRenderObjectWidget {\r\n  const _MenuItem({\r\n    Key? key,\r\n    required this.onLayout,\r\n    required this.item,\r\n  }) : super(key: key, child: item);\r\n\r\n  final ValueChanged<Size> onLayout;\r\n  final CustomDropdownMenuItem<T>? item;\r\n\r\n  @override\r\n  RenderObject createRenderObject(BuildContext context) {\r\n    return _RenderMenuItem(onLayout);\r\n  }\r\n\r\n  @override\r\n  void updateRenderObject(\r\n      BuildContext context, covariant _RenderMenuItem renderObject) {\r\n    renderObject.onLayout = onLayout;\r\n  }\r\n}\r\n\r\nclass _RenderMenuItem extends RenderProxyBox {\r\n  _RenderMenuItem(this.onLayout, [RenderBox? child]) : super(child);\r\n\r\n  ValueChanged<Size> onLayout;\r\n\r\n  @override\r\n  void performLayout() {\r\n    super.performLayout();\r\n    onLayout(size);\r\n  }\r\n}\r\n\r\nclass _DropdownMenuItemContainer extends StatelessWidget {\r\n  const _DropdownMenuItemContainer({\r\n    Key? key,\r\n    required this.child,\r\n  }) : super(key: key);\r\n\r\n  final Widget child;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Container(\r\n      constraints: const BoxConstraints(minHeight: _kMenuItemHeight),\r\n      alignment: AlignmentDirectional.centerStart,\r\n      child: child,\r\n    );\r\n  }\r\n}\r\n\r\nclass CustomDropdownMenuItem<T> extends _DropdownMenuItemContainer {\r\n  const CustomDropdownMenuItem({\r\n    Key? key,\r\n    this.onTap,\r\n    this.value,\r\n    required Widget child,\r\n  }) : super(key: key, child: child);\r\n\r\n  final VoidCallback? onTap;\r\n  final T? value;\r\n}\r\n\r\nclass CustomDropdownButtonHideUnderline extends InheritedWidget {\r\n  const CustomDropdownButtonHideUnderline({\r\n    Key? key,\r\n    required Widget child,\r\n  }) : super(key: key, child: child);\r\n\r\n  static bool at(BuildContext context) {\r\n    return context.dependOnInheritedWidgetOfExactType<\r\n            CustomDropdownButtonHideUnderline>() !=\r\n        null;\r\n  }\r\n\r\n  @override\r\n  bool updateShouldNotify(CustomDropdownButtonHideUnderline oldWidget) => false;\r\n}\r\n\r\nclass CustomDropdownButton<T> extends StatefulWidget {\r\n  CustomDropdownButton({\r\n    Key? key,\r\n    required this.items,\r\n    this.selectedItemBuilder,\r\n    this.value,\r\n    this.hint,\r\n    this.disabledHint,\r\n    this.onChanged,\r\n    this.onTap,\r\n    this.elevation = 8,\r\n    this.style,\r\n    this.underline,\r\n    this.icon,\r\n    this.iconDisabledColor,\r\n    this.iconEnabledColor,\r\n    this.iconSize = 24.0,\r\n    this.isDense = false,\r\n    this.isExpanded = false,\r\n    this.itemHeight = kMinInteractiveDimension,\r\n    this.focusColor,\r\n    this.focusNode,\r\n    this.autofocus = false,\r\n    this.dropdownColor,\r\n    this.menuMaxHeight,\r\n    required this.menuDirection,\r\n  })  : assert(\r\n          items == null ||\r\n              items.isEmpty ||\r\n              value == null ||\r\n              items.where((CustomDropdownMenuItem<T> item) {\r\n                    return item.value == value;\r\n                  }).length ==\r\n                  1,\r\n          \"There should be exactly one item with [DropdownButton]'s value: \"\r\n          '$value. \\n'\r\n          'Either zero or 2 or more [DropdownMenuItem]s were detected '\r\n          'with the same value',\r\n        ),\r\n        assert(itemHeight == null || itemHeight >= kMinInteractiveDimension),\r\n        super(key: key);\r\n\r\n  final DropdownMenuDirection menuDirection;\r\n  final List<CustomDropdownMenuItem<T>>? items;\r\n  final T? value;\r\n  final Widget? hint;\r\n  final Widget? disabledHint;\r\n  final ValueChanged<T?>? onChanged;\r\n  final VoidCallback? onTap;\r\n  final DropdownButtonBuilder? selectedItemBuilder;\r\n  final int elevation;\r\n  final TextStyle? style;\r\n  final Widget? underline;\r\n  final Widget? icon;\r\n  final Color? iconDisabledColor;\r\n  final Color? iconEnabledColor;\r\n  final double iconSize;\r\n  final bool isDense;\r\n  final bool isExpanded;\r\n  final double? itemHeight;\r\n  final Color? focusColor;\r\n  final FocusNode? focusNode;\r\n  final bool autofocus;\r\n  final Color? dropdownColor;\r\n  final double? menuMaxHeight;\r\n\r\n  @override\r\n  _DropdownButtonState<T> createState() => _DropdownButtonState<T>();\r\n}\r\n\r\nclass _DropdownButtonState<T> extends State<CustomDropdownButton<T>>\r\n    with WidgetsBindingObserver {\r\n  int? _selectedIndex;\r\n  _DropdownRoute<T>? _dropdownRoute;\r\n  Orientation? _lastOrientation;\r\n  FocusNode? _internalNode;\r\n  FocusNode? get focusNode => widget.focusNode ?? _internalNode;\r\n  bool _hasPrimaryFocus = false;\r\n  late Map<Type, Action<Intent>> _actionMap;\r\n  late FocusHighlightMode _focusHighlightMode;\r\n\r\n  FocusNode _createFocusNode() {\r\n    return FocusNode(debugLabel: '${widget.runtimeType}');\r\n  }\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _updateSelectedIndex();\r\n    if (widget.focusNode == null) {\r\n      _internalNode ??= _createFocusNode();\r\n    }\r\n    _actionMap = <Type, Action<Intent>>{\r\n      ActivateIntent: CallbackAction<ActivateIntent>(\r\n        onInvoke: (ActivateIntent intent) => _handleTap(),\r\n      ),\r\n      ButtonActivateIntent: CallbackAction<ButtonActivateIntent>(\r\n        onInvoke: (ButtonActivateIntent intent) => _handleTap(),\r\n      ),\r\n    };\r\n    focusNode!.addListener(_handleFocusChanged);\r\n    final focusManager = WidgetsBinding.instance.focusManager;\r\n    _focusHighlightMode = focusManager.highlightMode;\r\n    focusManager.addHighlightModeListener(_handleFocusHighlightModeChange);\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    WidgetsBinding.instance.removeObserver(this);\r\n    _removeDropdownRoute();\r\n    WidgetsBinding.instance.focusManager\r\n        .removeHighlightModeListener(_handleFocusHighlightModeChange);\r\n    focusNode!.removeListener(_handleFocusChanged);\r\n    _internalNode?.dispose();\r\n    super.dispose();\r\n  }\r\n\r\n  void _removeDropdownRoute() {\r\n    _dropdownRoute?._dismiss();\r\n    _dropdownRoute = null;\r\n    _lastOrientation = null;\r\n  }\r\n\r\n  void _handleFocusChanged() {\r\n    if (_hasPrimaryFocus != focusNode!.hasPrimaryFocus) {\r\n      this.setState(() {\r\n        _hasPrimaryFocus = focusNode!.hasPrimaryFocus;\r\n      });\r\n    }\r\n  }\r\n\r\n  void _handleFocusHighlightModeChange(FocusHighlightMode mode) {\r\n    if (!mounted) {\r\n      return;\r\n    }\r\n    this.setState(() {\r\n      _focusHighlightMode = mode;\r\n    });\r\n  }\r\n\r\n  @override\r\n  void didUpdateWidget(CustomDropdownButton<T> oldWidget) {\r\n    super.didUpdateWidget(oldWidget);\r\n    if (widget.focusNode != oldWidget.focusNode) {\r\n      oldWidget.focusNode?.removeListener(_handleFocusChanged);\r\n      if (widget.focusNode == null) {\r\n        _internalNode ??= _createFocusNode();\r\n      }\r\n      _hasPrimaryFocus = focusNode!.hasPrimaryFocus;\r\n      focusNode!.addListener(_handleFocusChanged);\r\n    }\r\n    _updateSelectedIndex();\r\n  }\r\n\r\n  void _updateSelectedIndex() {\r\n    if (widget.items == null ||\r\n        widget.items!.isEmpty ||\r\n        (widget.value == null &&\r\n            widget.items!\r\n                .where((CustomDropdownMenuItem<T> item) =>\r\n                    item.value == widget.value)\r\n                .isEmpty)) {\r\n      _selectedIndex = null;\r\n      return;\r\n    }\r\n\r\n    assert(widget.items!\r\n            .where(\r\n                (CustomDropdownMenuItem<T> item) => item.value == widget.value)\r\n            .length ==\r\n        1);\r\n    for (var itemIndex = 0; itemIndex < widget.items!.length; itemIndex++) {\r\n      if (widget.items![itemIndex].value == widget.value) {\r\n        _selectedIndex = itemIndex;\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  TextStyle? get _textStyle =>\r\n      widget.style ?? Theme.of(context).textTheme.titleMedium;\r\n\r\n  void _handleTap() {\r\n    final textDirection = Directionality.maybeOf(context);\r\n    final menuMargin = ButtonTheme.of(context).alignedDropdown\r\n        ? _kAlignedMenuMargin\r\n        : _kUnalignedMenuMargin;\r\n\r\n    final menuItems = <_MenuItem<T>>[\r\n      for (int index = 0; index < widget.items!.length; index += 1)\r\n        _MenuItem<T>(\r\n          item: widget.items![index],\r\n          onLayout: (Size size) {\r\n            if (_dropdownRoute == null) {\r\n              return;\r\n            }\r\n\r\n            _dropdownRoute!.itemHeights[index] = size.height;\r\n          },\r\n        ),\r\n    ];\r\n\r\n    final navigator = Navigator.of(context);\r\n    assert(_dropdownRoute == null);\r\n    final itemBox = context.findRenderObject()! as RenderBox;\r\n    final itemRect = itemBox.localToGlobal(Offset.zero,\r\n            ancestor: navigator.context.findRenderObject()) &\r\n        itemBox.size;\r\n\r\n    _dropdownRoute = _DropdownRoute<T>(\r\n      items: menuItems,\r\n      buttonRect: menuMargin.resolve(textDirection).inflateRect(itemRect),\r\n      padding: _kMenuItemPadding.resolve(textDirection),\r\n      selectedIndex: _selectedIndex ?? 0,\r\n      elevation: widget.elevation,\r\n      capturedThemes:\r\n          InheritedTheme.capture(from: context, to: navigator.context),\r\n      style: _textStyle!,\r\n      barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,\r\n      itemHeight: widget.itemHeight,\r\n      dropdownColor: widget.dropdownColor,\r\n      menuMaxHeight: widget.menuMaxHeight,\r\n      menuDirection: widget.menuDirection,\r\n    );\r\n\r\n    navigator\r\n        .push(_dropdownRoute!)\r\n        .then<void>((_DropdownRouteResult<T>? newValue) {\r\n      _removeDropdownRoute();\r\n      if (!mounted || newValue == null) {\r\n        return;\r\n      }\r\n      widget.onChanged?.call(newValue.result);\r\n    });\r\n\r\n    widget.onTap?.call();\r\n  }\r\n\r\n  double get _denseButtonHeight {\r\n    final fontSize = _textStyle!.fontSize ??\r\n        Theme.of(context).textTheme.titleMedium!.fontSize!;\r\n    return max(fontSize, max(widget.iconSize, _kDenseButtonHeight));\r\n  }\r\n\r\n  Color get _iconColor {\r\n    if (_enabled) {\r\n      if (widget.iconEnabledColor != null) {\r\n        return widget.iconEnabledColor!;\r\n      }\r\n\r\n      switch (Theme.of(context).brightness) {\r\n        case Brightness.light:\r\n          return Colors.grey.shade700;\r\n        case Brightness.dark:\r\n          return Colors.white70;\r\n      }\r\n    } else {\r\n      if (widget.iconDisabledColor != null) {\r\n        return widget.iconDisabledColor!;\r\n      }\r\n\r\n      switch (Theme.of(context).brightness) {\r\n        case Brightness.light:\r\n          return Colors.grey.shade400;\r\n        case Brightness.dark:\r\n          return Colors.white10;\r\n      }\r\n    }\r\n  }\r\n\r\n  bool get _enabled =>\r\n      widget.items != null &&\r\n      widget.items!.isNotEmpty &&\r\n      widget.onChanged != null;\r\n\r\n  Orientation _getOrientation(BuildContext context) {\r\n    var result = MediaQuery.maybeOf(context)?.orientation;\r\n    if (result == null) {\r\n      final Size size = window.physicalSize;\r\n      result = size.width > size.height\r\n          ? Orientation.landscape\r\n          : Orientation.portrait;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  bool get _showHighlight {\r\n    switch (_focusHighlightMode) {\r\n      case FocusHighlightMode.touch:\r\n        return false;\r\n      case FocusHighlightMode.traditional:\r\n        return _hasPrimaryFocus;\r\n    }\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    assert(debugCheckHasMaterial(context));\r\n    assert(debugCheckHasMaterialLocalizations(context));\r\n    final newOrientation = _getOrientation(context);\r\n    _lastOrientation ??= newOrientation;\r\n    if (newOrientation != _lastOrientation) {\r\n      _removeDropdownRoute();\r\n      _lastOrientation = newOrientation;\r\n    }\r\n\r\n    final items = widget.selectedItemBuilder == null\r\n        ? (widget.items != null ? List<Widget>.from(widget.items!) : <Widget>[])\r\n        : List<Widget>.from(widget.selectedItemBuilder!(context));\r\n\r\n    int? hintIndex;\r\n    if (widget.hint != null || (!_enabled && widget.disabledHint != null)) {\r\n      var displayedHint =\r\n          _enabled ? widget.hint! : widget.disabledHint ?? widget.hint!;\r\n      if (widget.selectedItemBuilder == null) {\r\n        displayedHint = _DropdownMenuItemContainer(child: displayedHint);\r\n      }\r\n\r\n      hintIndex = items.length;\r\n      items.add(DefaultTextStyle(\r\n        style: _textStyle!.copyWith(color: Theme.of(context).hintColor),\r\n        child: IgnorePointer(\r\n          ignoringSemantics: false,\r\n          child: displayedHint,\r\n        ),\r\n      ));\r\n    }\r\n\r\n    final padding = ButtonTheme.of(context).alignedDropdown\r\n        ? _kAlignedButtonPadding\r\n        : _kUnalignedButtonPadding;\r\n\r\n    final Widget innerItemsWidget;\r\n    if (items.isEmpty) {\r\n      innerItemsWidget = Container();\r\n    } else {\r\n      innerItemsWidget = IndexedStack(\r\n        index: _selectedIndex ?? hintIndex,\r\n        alignment: AlignmentDirectional.centerStart,\r\n        children: widget.isDense\r\n            ? items\r\n            : items.map((Widget item) {\r\n                return widget.itemHeight != null\r\n                    ? SizedBox(height: widget.itemHeight, child: item)\r\n                    : Column(\r\n                        mainAxisSize: MainAxisSize.min,\r\n                        children: <Widget>[item]);\r\n              }).toList(),\r\n      );\r\n    }\r\n\r\n    const defaultIcon = Icon(Icons.arrow_drop_down);\r\n\r\n    Widget result = DefaultTextStyle(\r\n      style: _enabled\r\n          ? _textStyle!\r\n          : _textStyle!.copyWith(color: Theme.of(context).disabledColor),\r\n      child: Container(\r\n        decoration: _showHighlight\r\n            ? BoxDecoration(\r\n                color: widget.focusColor ?? Theme.of(context).focusColor,\r\n                borderRadius: const BorderRadius.all(Radius.circular(4.0)),\r\n              )\r\n            : null,\r\n        padding: padding.resolve(Directionality.of(context)),\r\n        height: widget.isDense ? _denseButtonHeight : null,\r\n        child: Row(\r\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\r\n          mainAxisSize: MainAxisSize.min,\r\n          children: <Widget>[\r\n            if (widget.isExpanded)\r\n              Expanded(child: innerItemsWidget)\r\n            else\r\n              innerItemsWidget,\r\n            IconTheme(\r\n              data: IconThemeData(\r\n                color: _iconColor,\r\n                size: widget.iconSize,\r\n              ),\r\n              child: widget.icon ?? defaultIcon,\r\n            ),\r\n          ],\r\n        ),\r\n      ),\r\n    );\r\n\r\n    if (!CustomDropdownButtonHideUnderline.at(context)) {\r\n      final bottom = (widget.isDense || widget.itemHeight == null) ? 0.0 : 8.0;\r\n      result = Stack(\r\n        children: <Widget>[\r\n          result,\r\n          Positioned(\r\n            left: 0.0,\r\n            right: 0.0,\r\n            bottom: bottom,\r\n            child: widget.underline ??\r\n                Container(\r\n                  height: 1.0,\r\n                  decoration: const BoxDecoration(\r\n                    border: Border(\r\n                      bottom: BorderSide(\r\n                        color: Color(0xFFBDBDBD),\r\n                        width: 0.0,\r\n                      ),\r\n                    ),\r\n                  ),\r\n                ),\r\n          ),\r\n        ],\r\n      );\r\n    }\r\n\r\n    return Semantics(\r\n      button: true,\r\n      child: Actions(\r\n        actions: _actionMap,\r\n        child: Focus(\r\n          canRequestFocus: _enabled,\r\n          focusNode: focusNode,\r\n          autofocus: widget.autofocus,\r\n          child: GestureDetector(\r\n            onTap: _enabled ? _handleTap : null,\r\n            behavior: HitTestBehavior.opaque,\r\n            child: result,\r\n          ),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n"
        }
    ]
}